创造型：如何更好的new
AbstractFactory: 抽象工厂模式能帮你创建 “风格统一、必须一起使用的一组产品”，并且在创建这些产品时，你不需要写死具体产品的类名，只需要通过抽象工厂就能拿到对应产品族的所有产品。

Builder: 当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。

FactoryMethod: 工厂方法模式是简单工厂方法模式的升级版本，为了克服简单工厂方法模式的缺点而生，作用和简单工厂方法完全一样。

Prototype:你是一名画家，现在你创造了这个实际最伟大的作品。几十年后人们发明了复制机器，现在你的作品可以被无限量的复制出来，桀桀桀。

SimpleFactory:通过一个工厂方法根据不同的条件生产同一类型的产品

Singleton:当你希望整个系统运行期间某个类只有一个实例时候。



结构型
Adapter：将一个接口转换为客户端所期待的接口，从而使两个接口不兼容的类可以在一起工作。就是将目标类用一个新类包装一下，相当于在客户端与目标类直接加了一层。

Bridge：将两个独立的结构联系起来，而这两个被联系起来的结构可以独立的变化

Composite：当你的程序结构有类似树一样的层级关系时，例如文件系统，视图树，公司组织架构等等

Decorator:是在不必改变原类和使用继承的情况下，动态地扩展一个对象的功能

Facade:对外提供简单的交互接口，隐藏内部的复杂性。

Flyweight:当你的程序中存在大量相似对象，每个对象之间只是根据不同的使用场景有些许变化时。（对象池）

Proxy: 为其他对象提供一种代理以控制对这个对象的访问



命令型
Chain of Responsibility:每个处理器互相首尾连接在一起成为一条链，然后任务顺着这条链往下传，直到被某个处理器处理掉。

Command:将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求排队或记录日志，以及支持可撤销的操作。

Interpreter:定义一种语言的语法规则，并构建一个解释器来解释这种语言中的句子（表达式）

Iterator:提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。（foreach）

Mediator:通过一个 “中介者” 对象，集中处理多个对象（同事）之间的交互，使原本相互依赖的同事类解耦，不再直接通信。(星型拓扑结构)

Memento:在不破坏封闭的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以将对象恢复到原先保存的状态(保存系统)

Observer:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都可以得到通知并自动更新。

State:当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。(状态机)

Strategy:当你写代码的时候发现一个操作有好多种实现方法，而你需要根据不同的情况使用if-else等分支结构来确定使用哪种实现方式的时候，想一想这个模式。(一种行为提供多种实现方式)

TemplateMethod:在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中，使得子类可以在不改变一个算法的结构前提下即可重定义该算法的某些特定步骤

Visitor:封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于其内部各个元素的新操作(让一个牛马可以在不同需求下去做其他活，比如他既是程序员，也是策划，也是画师，也是建模师)
